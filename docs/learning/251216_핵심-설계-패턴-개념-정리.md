# 핵심 설계 패턴 및 개념 정리

> **작성일시**: 2025-12-16 23:46
>
> LookMarket 프로젝트에서 사용된 주요 디자인 패턴과 아키텍처 개념을 정리합니다.

---

## 목차

1. [Static Factory Method 패턴](#1-static-factory-method-패턴)
2. [Behavior-rich Entity (행위 중심 엔티티)](#2-behavior-rich-entity-행위-중심-엔티티)
3. [Orchestration (오케스트레이션)](#3-orchestration-오케스트레이션)
4. [Port & Adapter (Hexagonal Architecture)](#4-port--adapter-hexagonal-architecture)
5. [Dependency Inversion Principle (DIP)](#5-dependency-inversion-principle-dip)
6. [Value Object (값 객체)](#6-value-object-값-객체)
7. [Aggregate (애그리게이트)](#7-aggregate-애그리게이트)

---

## 1. Static Factory Method 패턴

### 정의

> **생성자 대신 static 메서드를 통해 객체를 생성하는 패턴**

일반 생성자(`new User(...)`)를 직접 호출하지 않고, 의미 있는 이름을 가진 정적 메서드를 통해 객체를 생성합니다.

### 비교 예시

```java
// ❌ 일반 생성자 - 의도가 불분명
User user1 = new User(null, "test@example.com", "password", ...);  // 신규?
User user2 = new User(1L, "test@example.com", "password", ...);    // 복원?

// ✅ Static Factory Method - 의도가 명확
User user1 = User.create("test@example.com", "password", ...);      // "생성"
User user2 = User.reconstitute(1L, "test@example.com", ...);        // "복원"
```

### 장점

| 장점 | 설명 | 예시 |
|------|------|------|
| **이름을 가질 수 있음** | 메서드명으로 의도 표현 | `create()`, `reconstitute()`, `of()`, `from()` |
| **호출할 때마다 새 객체 생성 불필요** | 캐싱된 인스턴스 반환 가능 | `Boolean.valueOf(true)` |
| **하위 타입 반환 가능** | 유연한 객체 생성 | `Collections.emptyList()` |
| **입력 매개변수에 따라 다른 객체 반환** | 조건부 생성 | `EnumSet.of()` |

### 자주 사용되는 명명 규칙

| 메서드명 | 의미 | 예시 |
|----------|------|------|
| `from` | 하나의 매개변수로 변환 | `Date.from(instant)` |
| `of` | 여러 매개변수로 생성 | `List.of(1, 2, 3)` |
| `valueOf` | from/of의 대안 | `BigInteger.valueOf(100)` |
| `create` / `newInstance` | 새 인스턴스 생성 | `User.create(...)` |
| `getInstance` | 인스턴스 반환 (캐싱 가능) | `Calendar.getInstance()` |

### LookMarket에서의 적용

```java
public class User {
    // 생성자는 package-private으로 숨김
    User(Long id, String email, ...) { ... }

    // ✅ 신규 사용자 생성용
    public static User create(String email, String password, ...) {
        return new User(
            null,           // ID는 DB에서 생성
            email,
            password,
            ...
            UserStatus.ACTIVE  // 항상 ACTIVE로 시작
        );
    }

    // ✅ DB에서 조회한 데이터 복원용
    public static User reconstitute(Long id, String email, ...) {
        return new User(id, email, ...);  // 그대로 복원
    }
}
```

### 참고 자료

- Effective Java 3판 - Item 1: "생성자 대신 정적 팩터리 메서드를 고려하라"

---

## 2. Behavior-rich Entity (행위 중심 엔티티)

### 정의

> **엔티티가 데이터뿐만 아니라 비즈니스 로직(행위)도 포함하는 설계 방식**

반대 개념인 **Anemic Domain Model (빈약한 도메인 모델)**과 비교됩니다.

### 비교

```java
// ❌ Anemic Domain Model (빈약한 도메인)
// 엔티티는 데이터만, 로직은 Service에
public class User {
    private String email;

    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }  // 단순 Setter
}

public class UserService {
    public void changeEmail(User user, String newEmail) {
        // 검증 로직이 Service에 있음 (나쁨)
        if (!isValidEmail(newEmail)) {
            throw new IllegalArgumentException("Invalid email");
        }
        user.setEmail(newEmail);  // 도메인 규칙 외부에
    }
}
```

```java
// ✅ Behavior-rich Entity (행위 중심)
// 엔티티가 자신의 규칙을 알고 있음
public class User {
    private String email;

    public void changeEmail(String newEmail) {
        validateEmail(newEmail);  // 검증 로직이 엔티티 내부에
        if (!this.email.equals(newEmail)) {
            this.email = newEmail;
            this.updatedAt = LocalDateTime.now();
        }
    }

    private void validateEmail(String email) {
        if (!email.matches("^[A-Za-z0-9+_.-]+@...")) {
            throw new IllegalArgumentException("올바른 이메일 형식이 아닙니다.");
        }
    }
}
```

### 핵심 비교표

| 원칙 | Anemic Model | Behavior-rich Model |
|------|-------------|---------------------|
| 로직 위치 | Service 레이어 | 엔티티 내부 |
| 엔티티 역할 | 데이터 컨테이너 | 비즈니스 객체 |
| Setter | public | 없거나 private |
| 메서드 이름 | `setEmail()` | `changeEmail()` |
| 불변식 보장 | Service가 책임 | 엔티티 스스로 책임 |

### DDD에서의 의미

Martin Fowler는 Anemic Domain Model을 **"안티패턴"**이라고 정의했습니다:

> "도메인 객체에 비즈니스 로직이 거의 없고, 단순히 getter/setter만 있는 것은 객체지향의 기본 아이디어를 위반한다."

### 참고 자료

- Martin Fowler - [Anemic Domain Model](https://martinfowler.com/bliki/AnemicDomainModel.html)
- Eric Evans - Domain-Driven Design

---

## 3. Orchestration (오케스트레이션)

### 정의

> **여러 구성 요소의 실행 흐름을 조율하고 조정하는 것**

오케스트라 지휘자처럼, 각 연주자(컴포넌트)가 언제 무엇을 할지 **중앙에서 제어**합니다.

### Application Service에서의 역할

```java
@Service
public class UserService {

    @Transactional
    public User changeEmail(Long userId, String newEmail) {
        // 오케스트레이션: 흐름을 조율할 뿐, 직접 로직을 수행하지 않음

        // 1. [조율] Repository에게 조회 요청
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new IllegalArgumentException("User not found"));

        // 2. [조율] Repository에게 중복 확인 요청
        if (userRepository.existsByEmail(newEmail)) {
            throw new IllegalArgumentException("Email already exists");
        }

        // 3. [위임] Domain에게 비즈니스 로직 위임
        user.changeEmail(newEmail);  // 검증은 User가 수행

        // 4. [조율] Repository에게 저장 요청
        return userRepository.save(user);
    }
}
```

### Service가 해야 할 것 vs 하면 안 되는 것

| Service가 해야 할 것 | Service가 하면 안 되는 것 |
|---------------------|------------------------|
| ✅ 트랜잭션 경계 관리 | ❌ 이메일 형식 검증 |
| ✅ Repository 호출 순서 조율 | ❌ 비즈니스 규칙 직접 구현 |
| ✅ 외부 서비스 호출 (암호화 등) | ❌ 도메인 객체 상태 직접 변경 |
| ✅ 예외 처리 및 변환 | ❌ 도메인 불변식 검증 |
| ✅ 이벤트 발행 조율 | ❌ 복잡한 계산 로직 |

### Orchestration vs Choreography

| 패턴 | 제어 방식 | 예시 |
|------|----------|------|
| **Orchestration** | 중앙 집중 (지휘자) | Application Service |
| **Choreography** | 분산 (각자 반응) | 이벤트 기반 아키텍처 |

#### Orchestration (현재 방식)

```
┌─────────────────┐
│  UserService    │ ← 중앙 제어
│  (지휘자)        │
└────────┬────────┘
         │ 호출
    ┌────┴────┬────────┐
    ▼         ▼        ▼
  User    Repository  Encoder
```

#### Choreography (이벤트 기반)

```
UserCreated 이벤트 발행
         │
    ┌────┴────┬────────┐
    ▼         ▼        ▼
 EmailSvc  PointSvc  LogSvc  ← 각자 반응
```

### LookMarket에서의 적용

- **Phase 1-3**: Orchestration 방식 (Application Service가 조율)
- **Phase 4**: Kafka 도입 후 일부 Choreography 방식 추가

---

## 4. Port & Adapter (Hexagonal Architecture)

### 정의

> **애플리케이션 핵심(Domain)을 외부 세계로부터 격리하는 아키텍처 패턴**

- **Port**: 인터페이스 (Domain이 정의)
- **Adapter**: 구현체 (Infrastructure가 제공)

### 시각화

```
              ┌────────────────────────────────────┐
              │           Application              │
              │  ┌──────────────────────────────┐  │
  HTTP ──────►│  │         Domain               │  │◄────── CLI
  Request     │  │   ┌──────────────────────┐   │  │
              │  │   │   Business Logic     │   │  │
              │  │   │   (User, Order...)   │   │  │
              │  │   └──────────────────────┘   │  │
              │  │              │               │  │
              │  │         [Port]               │  │
              │  │      UserRepository          │  │
              │  └──────────────────────────────┘  │
              │              │                     │
              │         [Adapter]                  │
              │       UserAdapter                  │
              └──────────────┬─────────────────────┘
                             │
                             ▼
                      ┌──────────────┐
                      │   Database   │
                      └──────────────┘
```

### Inbound vs Outbound

| 종류 | 방향 | Port 예시 | Adapter 예시 |
|------|------|----------|-------------|
| **Inbound** | 외부 → 애플리케이션 | UseCase 인터페이스 | Controller |
| **Outbound** | 애플리케이션 → 외부 | Repository 인터페이스 | JPA Adapter |

### LookMarket에서의 적용

```java
// Port (Domain Layer) - 추상화된 계약
public interface UserRepository {
    User save(User user);
    Optional<User> findById(Long id);
}

// Adapter (Infrastructure Layer) - 구체적 구현
@Component
public class UserAdapter implements UserRepository {
    private final JpaUserRepository jpaRepository;

    @Override
    public User save(User user) {
        UserEntity entity = UserEntity.fromDomain(user);
        UserEntity saved = jpaRepository.save(entity);
        return saved.toDomain();
    }
}
```

### 이점

| 이점 | 설명 |
|------|------|
| **테스트 용이성** | 가짜(Mock) Adapter로 교체 가능 |
| **기술 교체 유연성** | MySQL → PostgreSQL, JPA → jOOQ |
| **Domain 보호** | 외부 변경이 핵심 로직에 영향 없음 |

### 참고 자료

- Alistair Cockburn - [Hexagonal Architecture](https://alistair.cockburn.us/hexagonal-architecture/)

---

## 5. Dependency Inversion Principle (DIP)

### 정의

> **고수준 모듈이 저수준 모듈에 의존하면 안 되고, 둘 다 추상화에 의존해야 한다**

SOLID 원칙 중 'D'에 해당합니다.

### 잘못된 의존 방향 vs 올바른 의존 방향

```
❌ 잘못된 방향:
Domain ───────► JpaUserRepository (Spring Data JPA)
              Domain이 Infrastructure를 직접 알고 있음

✅ 올바른 방향 (DIP 적용):
Domain: UserRepository (인터페이스)
              ▲
              │ implements
Infrastructure: UserAdapter
              Domain이 추상화를 정의하고, Infrastructure가 구현
```

### 코드로 보는 DIP

```java
// ❌ DIP 위반: Domain이 JPA에 의존
package com.lookmarket.domain.user;

import org.springframework.data.jpa.repository.JpaRepository;  // ❌ 프레임워크 의존

public interface UserRepository extends JpaRepository<User, Long> { }
```

```java
// ✅ DIP 준수: Domain은 순수 인터페이스만 정의
package com.lookmarket.domain.user;

public interface UserRepository {  // 프레임워크 의존 없음
    User save(User user);
    Optional<User> findById(Long id);
}

// Infrastructure에서 구현
package com.lookmarket.infrastructure.user;

@Component
public class UserAdapter implements UserRepository {
    // JPA 사용은 여기서만
}
```

### 왜 중요한가?

| 위반 시 문제 | DIP 적용 시 장점 |
|-------------|-----------------|
| JPA 변경 시 Domain 수정 필요 | Domain은 변경 불필요 |
| 테스트 시 DB 필요 | Mock으로 대체 가능 |
| 프레임워크에 종속 | 프레임워크 교체 용이 |

### 참고 자료

- Robert C. Martin - Clean Architecture
- SOLID Principles

---

## 6. Value Object (값 객체)

### 정의

> **식별자(ID) 없이 속성 값으로만 동등성을 판단하는 불변 객체**

Entity와 대비되는 개념입니다.

### Entity vs Value Object

| 구분 | Entity | Value Object |
|------|--------|--------------|
| 식별 | ID로 구분 | 값으로 구분 |
| 동등성 | `id`가 같으면 같음 | 모든 속성이 같으면 같음 |
| 가변성 | 상태 변경 가능 | **불변** |
| 생명주기 | 독립적 | Entity에 종속 |
| 예시 | User, Order | Money, Address, Email |

### 예시 (향후 LookMarket에 추가 가능)

```java
// Value Object 예시
public record Money(BigDecimal amount, Currency currency) {

    public Money {
        if (amount.compareTo(BigDecimal.ZERO) < 0) {
            throw new IllegalArgumentException("금액은 0 이상이어야 합니다.");
        }
    }

    public Money add(Money other) {
        if (!this.currency.equals(other.currency)) {
            throw new IllegalArgumentException("Currency mismatch");
        }
        return new Money(this.amount.add(other.amount), this.currency);
    }

    // 불변: 새 객체 반환
}

// 사용
Money price1 = new Money(new BigDecimal("10000"), Currency.KRW);
Money price2 = new Money(new BigDecimal("10000"), Currency.KRW);

price1.equals(price2);  // true (값이 같으므로)
```

### Java Record가 Value Object에 적합한 이유

```java
// Record는 자동으로:
// - 불변 (final 필드)
// - equals/hashCode (모든 필드 기반)
// - toString
public record Email(String value) {
    public Email {  // Compact Constructor
        if (!value.matches("^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$")) {
            throw new IllegalArgumentException("Invalid email format");
        }
    }
}
```

### Value Object 사용 시점

| 상황 | Value Object 사용 |
|------|------------------|
| 개념적으로 하나의 값을 표현 | ✅ (예: Money = amount + currency) |
| 불변이어야 함 | ✅ |
| 동등성을 값으로 판단 | ✅ |
| 독립적인 생명주기 필요 | ❌ (Entity 사용) |

### 참고 자료

- Eric Evans - Domain-Driven Design (Chapter 5: Value Objects)

---

## 7. Aggregate (애그리게이트)

### 정의

> **하나의 단위로 취급되는 연관된 객체들의 묶음**

- **Aggregate Root**: 외부에서 접근하는 유일한 진입점
- **경계**: Aggregate 내부의 일관성을 보장하는 범위

### 예시: Order Aggregate

```
Order (Aggregate Root)
├── OrderItem
├── OrderItem
└── ShippingAddress (Value Object)

규칙:
- 외부에서 OrderItem에 직접 접근 불가
- Order를 통해서만 OrderItem 조작
- Order가 전체 일관성 책임
```

### 코드 예시

```java
public class Order {  // Aggregate Root
    private Long id;
    private List<OrderItem> items;  // 내부에서만 관리

    public void addItem(Product product, int quantity) {
        // Order가 OrderItem 생성을 제어
        OrderItem item = new OrderItem(product.getId(), quantity, product.getPrice());
        this.items.add(item);
        // 총액 재계산 등 일관성 유지
    }

    // 외부에서 items에 직접 접근 불가
    public List<OrderItem> getItems() {
        return Collections.unmodifiableList(items);  // 읽기 전용
    }
}
```

### Aggregate 규칙

| 규칙 | 설명 |
|------|------|
| **Root로만 접근** | 외부에서 내부 객체 직접 참조 금지 |
| **ID로 참조** | 다른 Aggregate는 ID로만 참조 |
| **트랜잭션 경계** | 하나의 트랜잭션에서 하나의 Aggregate만 수정 |
| **일관성 경계** | Aggregate 내부는 항상 일관된 상태 유지 |

### Aggregate 간 참조 규칙

```java
// ❌ 잘못된 방식: 다른 Aggregate를 직접 참조
public class Order {
    private User user;      // User Aggregate 직접 참조
    private Product product; // Product Aggregate 직접 참조
}

// ✅ 올바른 방식: ID로만 참조
public class Order {
    private Long userId;     // ID만 저장
    private Long productId;  // ID만 저장
}
```

### 왜 ID로 참조하는가?

| 직접 참조 문제 | ID 참조 장점 |
|--------------|-------------|
| Aggregate 경계가 모호해짐 | 경계 명확 |
| 트랜잭션 범위가 커짐 | 트랜잭션 분리 가능 |
| 지연 로딩 복잡성 | 필요할 때 별도 조회 |
| 테스트 어려움 | 테스트 용이 |

### LookMarket에서의 Aggregate 예상 구조

```
User Aggregate          Product Aggregate       Order Aggregate
├── User (Root)         ├── Product (Root)      ├── Order (Root)
└── (향후) Address      ├── ProductOption       ├── OrderItem
                        └── ProductImage        └── (향후) Payment
```

### 참고 자료

- Eric Evans - Domain-Driven Design (Chapter 6: Aggregates)
- Vaughn Vernon - Implementing Domain-Driven Design

---

## 개념 요약 카드

| 개념 | 한 줄 정의 | LookMarket 적용 |
|------|-----------|----------------|
| **Static Factory Method** | 생성자 대신 이름 있는 정적 메서드로 객체 생성 | `User.create()`, `User.reconstitute()` |
| **Behavior-rich Entity** | 엔티티가 비즈니스 로직을 직접 포함 | `user.changeEmail()`, `user.activate()` |
| **Orchestration** | 여러 컴포넌트의 실행 흐름을 중앙에서 조율 | `UserService`가 Repository, Domain 조율 |
| **Port & Adapter** | 인터페이스(Port)로 외부와 분리, 구현(Adapter)은 별도 | `UserRepository`(Port), `UserAdapter`(Adapter) |
| **DIP** | 고수준이 저수준에 의존하지 않고 추상화에 의존 | Domain이 JPA 모름, Interface만 정의 |
| **Value Object** | ID 없이 값으로 동등성 판단하는 불변 객체 | (향후) Money, Address 등 |
| **Aggregate** | 일관성 경계를 가진 객체 묶음, Root로만 접근 | User, Order 등이 Aggregate Root |

---

## 참고 자료 종합

- **Effective Java 3판** - Joshua Bloch
- **Clean Architecture** - Robert C. Martin
- **Domain-Driven Design** - Eric Evans
- **Implementing Domain-Driven Design** - Vaughn Vernon
- **Hexagonal Architecture** - Alistair Cockburn
